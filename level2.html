<!doctype html>
<html lang="nl">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Protocol 50 — Round: Action Icons</title>

    <style>
        :root{
            --green:#00ff66;
            --bg:#0b0f14;
            --panel:rgba(0,0,0,.55);
            --bad:#ef4444;
        }
        html,body{height:100%}
        body{
            margin:0;
            background: radial-gradient(1200px 600px at 70% 0%, #111827 0%, var(--bg) 55%);
            color:var(--green);
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
            overflow-x:hidden;
        }

        /* CRT scanlines + flicker (subtle) */
        body::before{
            content:"";
            position:fixed; inset:0; pointer-events:none;
            background: repeating-linear-gradient(to bottom, rgba(0,0,0,0) 0px, rgba(0,0,0,0) 2px, rgba(0,0,0,.18) 3px);
            mix-blend-mode:multiply;
            opacity:.22;
            z-index:2;
        }
        body::after{
            content:"";
            position:fixed; inset:0; pointer-events:none;
            background: radial-gradient(ellipse at center, rgba(0,0,0,0) 45%, rgba(0,0,0,.72) 100%),
            linear-gradient(to bottom, rgba(0,0,0,.22), rgba(0,0,0,.48));
            z-index:2;
            animation:flicker 4.2s infinite;
        }
        @keyframes flicker{
            0%,100%{opacity:1}
            41%{opacity:.92}
            42%{opacity:1}
            74%{opacity:.95}
            75%{opacity:1}
            88%{opacity:.9}
            89%{opacity:1}
        }

        .round{
            max-width:1100px;
            margin:0 auto;
            padding:24px 16px 40px;
            position:relative;
            z-index:3;
        }
        h2{
            margin:0 0 6px;
            letter-spacing:.18em;
        }
        .sub{
            color:rgba(0,255,102,.7);
            margin-bottom:14px;
            line-height:1.4;
        }

        .heroes{
            display:grid;
            grid-template-columns:repeat(5,1fr);
            gap:14px;
        }
        @media (max-width:900px){ .heroes{grid-template-columns:repeat(4,1fr);} }
        @media (max-width:700px){ .heroes{grid-template-columns:repeat(3,1fr);} }
        @media (max-width:480px){ .heroes{grid-template-columns:repeat(2,1fr);} }

        .hero{
            background:var(--panel);
            border:1px solid rgba(0,255,102,.25);
            border-radius:14px;
            padding:12px 10px 14px;
            display:flex;
            flex-direction:column;
            align-items:center;
            gap:10px;
            user-select:none;
        }
        .hero.correct{
            border-color:rgba(0,255,102,.85);
            box-shadow:0 0 22px rgba(0,255,102,.32);
        }
        .slot{
            font-size:12px;
            letter-spacing:.12em;
            color:rgba(0,255,102,.75);
        }

        canvas.sprite{
            width:144px;      /* 48 × 3 */
            height:192px;     /* 64 × 3 */
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            background:#071014;
            border-radius:12px;
            border:1px solid rgba(0,255,102,.18);
        }
        @media (max-width:700px){
            canvas.sprite{ width:120px; height:160px; }
        }


        .names{
            margin-top:22px;
            display:flex;
            flex-wrap:wrap;
            gap:10px;
            justify-content:center;
        }
        .name{
            padding:10px 12px;
            border-radius:10px;
            border:1px solid rgba(0,255,102,.35);
            background:rgba(0,255,102,.08);
            cursor:grab;
            user-select:none;
            font-size:13px;
            letter-spacing:.04em;
        }
        .name.dragging{opacity:.5}
        .name.used{opacity:.35; cursor:not-allowed}

        /* Mobile/click fallback */
        .hint{
            margin-top:12px;
            text-align:center;
            color:rgba(0,255,102,.6);
            font-size:12px;
        }

        /* Feedback flash */
        .flash{
            position:fixed; inset:0;
            pointer-events:none;
            opacity:0;
            z-index:4;
        }
        .flash.bad{ background:rgba(255,0,0,.18); }
        .flash.ok{ background:rgba(0,255,102,.12); }
        .flash.on{ animation:flash .35s ease; }
        @keyframes flash{
            0%{opacity:0}
            20%{opacity:1}
            100%{opacity:0}
        }

        .complete{
            margin-top:14px;
            text-align:center;
            letter-spacing:.12em;
            display:none;
        }
        .complete.show{display:block}
    </style>
</head>

<body>
<div class="flash bad" id="flashBad"></div>
<div class="flash ok" id="flashOk"></div>

<section class="round" id="round-heroes">
    <h2>ROUND — ACTION ICONS</h2>
    <div class="sub">Sleep elke naam naar de juiste pixelheld (Amiga-style). Audio start automatisch bij je eerste actie.</div>

    <div class="heroes" id="heroes">
        <div class="hero" data-answer="Rambo"><canvas class="sprite" data-sprite="rambo" width="48" height="64"></canvas><div class="slot">DROP NAME</div></div>
        <div class="hero" data-answer="Terminator"><canvas class="sprite" data-sprite="terminator" width="48" height="64"></canvas><div class="slot">DROP NAME</div></div>
        <div class="hero" data-answer="John McClane"><canvas class="sprite" data-sprite="mcclane" width="48" height="64"></canvas><div class="slot">DROP NAME</div></div>
        <div class="hero" data-answer="Predator"><canvas class="sprite" data-sprite="predator" width="48" height="64"></canvas><div class="slot">DROP NAME</div></div>
        <div class="hero" data-answer="RoboCop"><canvas class="sprite" data-sprite="robocop" width="48" height="64"></canvas><div class="slot">DROP NAME</div></div>
        <div class="hero" data-answer="Indiana Jones"><canvas class="sprite" data-sprite="indy" width="48" height="64"></canvas><div class="slot">DROP NAME</div></div>
        <div class="hero" data-answer="Ellen Ripley"><canvas class="sprite" data-sprite="ripley" width="48" height="64"></canvas><div class="slot">DROP NAME</div></div>

        <!-- Replacements -->
        <div class="hero" data-answer="Inspector Lee"><canvas class="sprite" data-sprite="inspectorlee" width="48" height="64"></canvas><div class="slot">DROP NAME</div></div>
        <div class="hero" data-answer="Frank Dux"><canvas class="sprite" data-sprite="frankdux" width="48" height="64"></canvas><div class="slot">DROP NAME</div></div>
        <div class="hero" data-answer="Casey Ryback"><canvas class="sprite" data-sprite="caseyryback" width="48" height="64"></canvas><div class="slot">DROP NAME</div></div>
    </div>

    <div class="names" id="names">
        <div class="name" draggable="true">RoboCop</div>
        <div class="name" draggable="true">Rambo</div>
        <div class="name" draggable="true">Predator</div>
        <div class="name" draggable="true">Indiana Jones</div>
        <div class="name" draggable="true">John McClane</div>
        <div class="name" draggable="true">Ellen Ripley</div>
        <div class="name" draggable="true">Terminator</div>
        <div class="name" draggable="true">Inspector Lee</div>
        <div class="name" draggable="true">Frank Dux</div>
        <div class="name" draggable="true">Casey Ryback</div>
    </div>

    <div class="hint">Tip: op mobiel werkt drag&drop niet altijd; klik dan eerst op een naam en daarna op een hero.</div>
    <div class="complete" id="complete">ALL IDENTITIES CONFIRMED ✓</div>
</section>

<script>
    (() => {
        // ===========================
        // (1) Amiga-ish SFX (Web Audio)
        // - auto-unlock on first user gesture
        // ===========================
        let audioCtx = null, master = null, audioUnlocked = false;

        function ensureAudioUnlocked(){
            if(audioUnlocked) return;
            try{
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                master = audioCtx.createGain();
                master.gain.value = 0.12;
                master.connect(audioCtx.destination);
                audioUnlocked = true;
            }catch(e){
                // Audio not available; ignore
                audioUnlocked = false;
            }
        }

        async function resumeAudioIfNeeded(){
            if(!audioCtx) return;
            try{
                if(audioCtx.state === "suspended") await audioCtx.resume();
            }catch(e){}
        }

        function beep(freq=660, dur=0.06, type="square"){
            if(!audioCtx) return;
            const now = audioCtx.currentTime;
            const o = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            const f = audioCtx.createBiquadFilter();

            o.type = type;
            o.frequency.setValueAtTime(freq, now);

            f.type = "lowpass";
            f.frequency.setValueAtTime(2200, now);

            g.gain.setValueAtTime(0.0001, now);
            g.gain.exponentialRampToValueAtTime(0.85, now + 0.004);
            g.gain.exponentialRampToValueAtTime(0.0001, now + dur);

            o.connect(f); f.connect(g); g.connect(master);
            o.start(now);
            o.stop(now + dur + 0.01);
        }

        function clicky(){
            beep(740, 0.04, "square");
        }
        function wrong(){
            beep(260, 0.08, "square");
            setTimeout(() => beep(220, 0.08, "square"), 90);
        }
        function correct(){
            beep(660, 0.05, "square");
            setTimeout(() => beep(880, 0.06, "square"), 80);
        }
        function completeSfx(){
            // little "module complete" arpeggio
            const seq = [520, 660, 780, 1040];
            seq.forEach((f, i) => setTimeout(() => beep(f, 0.06, "square"), i*90));
        }

        // ===========================
// Amiga-ish palette + renderer (works for 32x48)
// ===========================
        (() => {
            // --- Amiga-ish palette (OCS/ECS vibe) ---
            const C = {
                K:"#071014", // black
                W:"#e8f1f2", // highlight
                H:"#2a1a14", // hair/boots
                S:"#c98b62", // skin mid
                T:"#8c5a3c", // skin shadow / leather
                O:"#d38b2c", // hat/jacket
                Y:"#f4d54a", // buckle/accent
                B:"#2b6cff", // pants blue
                b:"#1c3b8f", // pants shadow
                G:"#2b3a4a", // dark gear
                g:"#4b6076", // metal mid
                R:"#d83b3b", // red
                P:"#7d7dd6", // tech tint
                N:"#00c853", // green accent
            };

            function dither(x,y,a,b){ return ((x+y)&1) ? a : b; }

            function px(ctx, x,y, col){ ctx.fillStyle = col; ctx.fillRect(x,y,1,1); }
            function rect(ctx, x,y,w,h, col){
                ctx.fillStyle = col;
                ctx.fillRect(x,y,w,h);
            }
            function outline(ctx, x,y,w,h, col){
                rect(ctx,x,y,w,1,col);
                rect(ctx,x,y+h-1,w,1,col);
                rect(ctx,x,y,1,h,col);
                rect(ctx,x+w-1,y,1,h,col);
            }
            function noise(ctx){
                for(let i=0;i<120;i++){
                    ctx.fillStyle = Math.random()>0.5 ? "rgba(255,255,255,.03)" : "rgba(0,0,0,.12)";
                    ctx.fillRect((Math.random()*48)|0, (Math.random()*64)|0, 1, 1);
                }
            }
            function shade(ctx, x,y,w,h, mode="shadow"){
                for(let yy=y; yy<y+h; yy++){
                    for(let xx=x; xx<x+w; xx++){
                        const col = mode==="shadow"
                          ? dither(xx,yy,"rgba(0,0,0,.22)","rgba(0,0,0,0)")
                          : dither(xx,yy,"rgba(255,255,255,.12)","rgba(255,255,255,0)");
                        if(col.endsWith(",0)")) continue;
                        px(ctx,xx,yy,col);
                    }
                }
            }

            // --- Rick Dangerous-ish base body proportions ---
            // Big head, compact torso, chunky boots
            function drawBase(ctx, cfg){
                // background
                rect(ctx,0,0,48,64,C.K);
                noise(ctx);

                const cx = 24;

                // Head (oval-ish via rectangles + shading)
                const headW = 18, headH = 18;
                const headX = cx - (headW>>1);
                const headY = 6;

                rect(ctx, headX+2, headY+2, headW-4, headH-4, C.S);
                rect(ctx, headX+1, headY+3, headW-2, headH-6, C.S);
                rect(ctx, headX+3, headY+1, headW-6, headH-2, C.S);

                // Face edge shadow
                rect(ctx, headX+1, headY+4, 2, headH-8, C.T);
                rect(ctx, headX+headW-3, headY+4, 2, headH-8, C.T);
                rect(ctx, headX+4, headY+headH-3, headW-8, 2, C.T);

                // Eyes (pixel dots)
                px(ctx, cx-5, headY+9, C.K); px(ctx, cx-4, headY+9, C.W);
                px(ctx, cx+4, headY+9, C.K); px(ctx, cx+5, headY+9, C.W);

                // Nose/mouth
                px(ctx, cx, headY+11, C.T);
                rect(ctx, cx-2, headY+14, 5, 1, C.H);

                // Hair / helmet top
                if(cfg.hair){
                    rect(ctx, headX+2, headY+1, headW-4, 4, cfg.hair);
                    rect(ctx, headX+3, headY+4, headW-6, 2, cfg.hair);
                }

                // Torso
                const torsoW = 22, torsoH = 20;
                const torsoX = cx - (torsoW>>1);
                const torsoY = 24;

                rect(ctx, torsoX+2, torsoY, torsoW-4, torsoH, cfg.torso);
                rect(ctx, torsoX, torsoY+2, torsoW, torsoH-4, cfg.torso);

                // Torso shading
                rect(ctx, torsoX, torsoY+2, 3, torsoH-4, cfg.torsoShadow ?? C.G);
                rect(ctx, torsoX+torsoW-3, torsoY+2, 2, torsoH-4, cfg.torsoShadow ?? C.G);
                shade(ctx, torsoX+2, torsoY+2, torsoW-4, torsoH-4, "light");

                // Belt
                rect(ctx, torsoX+3, torsoY+torsoH-5, torsoW-6, 2, cfg.belt ?? C.T);
                rect(ctx, cx-1, torsoY+torsoH-5, 3, 2, C.Y);

                // Arms (slight pose)
                rect(ctx, torsoX-5, torsoY+4, 6, 12, cfg.arm ?? cfg.torso);
                rect(ctx, torsoX+torsoW-1, torsoY+4, 6, 12, cfg.arm ?? cfg.torso);
                rect(ctx, torsoX-4, torsoY+14, 5, 4, C.S);
                rect(ctx, torsoX+torsoW-1, torsoY+14, 5, 4, C.S);

                // Legs
                const legY = torsoY + torsoH;
                rect(ctx, cx-9, legY, 8, 14, cfg.pants);
                rect(ctx, cx+1, legY, 8, 14, cfg.pants);
                rect(ctx, cx-9, legY, 2, 14, cfg.pantsShadow ?? C.b);
                rect(ctx, cx+7, legY, 2, 14, cfg.pantsShadow ?? C.b);

                // Boots
                rect(ctx, cx-10, legY+14, 10, 5, cfg.boots ?? C.H);
                rect(ctx, cx, legY+14, 10, 5, cfg.boots ?? C.H);

                // Ground shadow
                shade(ctx, 6, 58, 36, 4, "shadow");

                // Optional: collar/straps
                if(cfg.straps){
                    rect(ctx, torsoX+6, torsoY+2, 3, torsoH-6, cfg.straps);
                    rect(ctx, torsoX+13, torsoY+2, 3, torsoH-6, cfg.straps);
                }

                // Optional: chest plate/armor
                if(cfg.armor){
                    rect(ctx, torsoX+4, torsoY+4, torsoW-8, 10, cfg.armor);
                    outline(ctx, torsoX+4, torsoY+4, torsoW-8, 10, cfg.armorEdge ?? C.G);
                    shade(ctx, torsoX+5, torsoY+5, torsoW-10, 8, "light");
                }

                // Optional: visor/glasses
                if(cfg.visor){
                    rect(ctx, cx-8, headY+8, 16, 5, cfg.visor);
                    px(ctx, cx-6, headY+10, C.W); px(ctx, cx+6, headY+10, C.W);
                }

                // Optional: hat
                if(cfg.hat){
                    rect(ctx, headX-2, headY+2, headW+4, 3, cfg.hat);
                    rect(ctx, headX+2, headY, headW-4, 4, cfg.hat);
                    rect(ctx, headX-4, headY+4, headW+8, 2, cfg.hat);
                }

                // Optional: mask
                if(cfg.mask){
                    rect(ctx, headX+3, headY+8, headW-6, 8, cfg.mask);
                    outline(ctx, headX+3, headY+8, headW-6, 8, cfg.maskEdge ?? C.G);
                    px(ctx, cx-4, headY+11, cfg.maskEye ?? C.N);
                    px(ctx, cx+4, headY+11, cfg.maskEye ?? C.N);
                }

                // Optional: weapon (simple)
                if(cfg.weapon === "pistol"){
                    // right hand pistol
                    rect(ctx, torsoX+torsoW+2, torsoY+10, 5, 2, C.G);
                    rect(ctx, torsoX+torsoW+4, torsoY+12, 2, 4, C.G);
                    rect(ctx, torsoX+torsoW+6, torsoY+10, 2, 1, C.W);
                }
                if(cfg.weapon === "rifle"){
                    // across chest
                    rect(ctx, torsoX+3, torsoY+8, torsoW+8, 2, C.G);
                    rect(ctx, torsoX+torsoW+8, torsoY+7, 2, 4, C.G);
                    rect(ctx, torsoX+2, torsoY+7, 2, 4, C.G);
                    rect(ctx, torsoX+torsoW+7, torsoY+8, 3, 1, C.W);
                }
                if(cfg.weapon === "whip"){
                    // whip curl
                    for(let i=0;i<12;i++){
                        px(ctx, torsoX+torsoW+2+i, torsoY+2+i, C.T);
                        if(i%3===0) px(ctx, torsoX+torsoW+3+i, torsoY+2+i, C.O);
                    }
                }
            }

            // --- Specific hero stylings (consistent with Indy sprite vibe) ---
            const SPRITE_DRAWERS = {
                // Indiana Jones (hat + whip + brown jacket + blue pants)
                indy: (ctx) => drawBase(ctx,{
                    hair:C.H,
                    hat:C.O,
                    torso:C.O,
                    torsoShadow:C.T,
                    pants:C.B,
                    pantsShadow:C.b,
                    boots:C.H,
                    belt:C.T,
                    weapon:"whip"
                }),

                // Rambo (red bandana + rugged + rifle)
                rambo: (ctx) => {
                    drawBase(ctx,{
                        hair:C.H,
                        torso:C.O,
                        torsoShadow:C.T,
                        pants:C.B,
                        pantsShadow:C.b,
                        boots:C.H,
                        belt:C.T,
                        straps:C.G,
                        weapon:"rifle"
                    });
                    // bandana
                    rect(ctx, 24-10, 8, 20, 3, C.R);
                    rect(ctx, 24-9, 11, 18, 1, C.R);
                },

                // Terminator (glasses + leather/metal + pistol)
                terminator: (ctx) => drawBase(ctx,{
                    hair:C.H,
                    visor:C.K,
                    torso:C.G,
                    torsoShadow:C.K,
                    pants:C.G,
                    pantsShadow:C.K,
                    boots:C.H,
                    belt:C.K,
                    weapon:"pistol"
                }),

                // John McClane (white vest + blue pants + small blood)
                mcclane: (ctx) => {
                    drawBase(ctx,{
                        hair:C.H,
                        torso:C.W,
                        torsoShadow:C.g,
                        pants:C.B,
                        pantsShadow:C.b,
                        boots:C.H,
                        belt:C.T,
                        straps:C.G,
                        weapon:"pistol"
                    });
                    // blood cut
                    px(ctx, 34, 18, C.R); px(ctx, 35, 18, C.R);
                    px(ctx, 35, 19, C.R);
                },

                // Predator (mask + dreadlocks + tech tint)
                predator: (ctx) => {
                    drawBase(ctx,{
                        hair:C.H,
                        torso:C.G,
                        torsoShadow:C.K,
                        pants:C.G,
                        pantsShadow:C.K,
                        boots:C.H,
                        belt:C.G,
                        mask:C.G,
                        maskEdge:C.g,
                        maskEye:C.N,
                        armor:C.P,
                        armorEdge:C.G
                    });
                    // dreadlocks
                    for(let x=8; x<=40; x+=6){
                        rect(ctx, x, 10, 2, 18, C.H);
                        if(x%12===0) rect(ctx, x+2, 12, 2, 18, C.H);
                    }
                    // mandible hint
                    rect(ctx, 24-6, 22, 12, 2, C.O);
                    rect(ctx, 24-4, 20, 8, 2, C.Y);
                },

                // RoboCop (helmet + visor + chest armor)
                robocop: (ctx) => drawBase(ctx,{
                    hair:C.g,
                    visor:C.K,
                    torso:C.g,
                    torsoShadow:C.G,
                    pants:C.G,
                    pantsShadow:C.K,
                    boots:C.H,
                    belt:C.G,
                    armor:C.g,
                    armorEdge:C.G,
                    weapon:"pistol"
                }),

                // Ripley (blue jumpsuit + rifle + short hair)
                ripley: (ctx) => drawBase(ctx,{
                    hair:C.H,
                    torso:C.b,
                    torsoShadow:C.G,
                    pants:C.b,
                    pantsShadow:C.G,
                    boots:C.H,
                    belt:C.T,
                    straps:C.G,
                    weapon:"rifle"
                }),

                // Inspector Lee (suit-ish + badge)
                inspectorlee: (ctx) => {
                    drawBase(ctx,{
                        hair:C.H,
                        torso:C.G,
                        torsoShadow:C.K,
                        pants:C.G,
                        pantsShadow:C.K,
                        boots:C.H,
                        belt:C.K,
                        weapon:"pistol"
                    });
                    // tie + badge
                    rect(ctx, 24-1, 27, 2, 10, C.R);
                    rect(ctx, 14, 30, 3, 3, C.Y);
                },

                // Frank Dux (headband + gi pants + fighting vibe)
                frankdux: (ctx) => {
                    drawBase(ctx,{
                        hair:C.H,
                        torso:C.W,
                        torsoShadow:C.g,
                        pants:C.B,
                        pantsShadow:C.b,
                        boots:C.H,
                        belt:C.R,      // red belt
                        straps:C.W
                    });
                    rect(ctx, 24-10, 8, 20, 3, C.R); // headband
                    rect(ctx, 24+8, 9, 4, 2, C.R);   // headband tail
                },

                // Casey Ryback (dark tactical + stern)
                caseyryback: (ctx) => drawBase(ctx,{
                    hair:C.H,
                    torso:C.G,
                    torsoShadow:C.K,
                    pants:C.G,
                    pantsShadow:C.K,
                    boots:C.H,
                    belt:C.K,
                    armor:C.G,
                    armorEdge:C.K,
                    weapon:"pistol"
                }),
            };

            // --- render all canvases ---
            document.querySelectorAll("canvas.sprite").forEach(cv => {
                const key = cv.dataset.sprite;
                const drawFn = SPRITE_DRAWERS[key];
                if(!drawFn) return;
                const ctx = cv.getContext("2d");
                drawFn(ctx);

                // subtle green frame like your UI theme
                ctx.globalAlpha = 0.25;
                ctx.fillStyle = C.N;
                ctx.fillRect(0,0,48,1);
                ctx.fillRect(0,63,48,1);
                ctx.fillRect(0,0,1,64);
                ctx.fillRect(47,0,1,64);
                ctx.globalAlpha = 1;
            });
        })();

        function dither(ctx, x, y, mode){
            const isChecker = ((x + y) & 1) === 0;
            if(mode === "shadow"){
                ctx.fillStyle = isChecker ? "rgba(0,0,0,.18)" : "rgba(0,0,0,.00)";
                ctx.fillRect(x, y, 1, 1);
            } else if(mode === "light"){
                ctx.fillStyle = isChecker ? "rgba(255,255,255,.10)" : "rgba(255,255,255,.00)";
                ctx.fillRect(x, y, 1, 1);
            }
        }

        function drawSprite(cv, map){
            const ctx = cv.getContext("2d");
            ctx.fillStyle = C.K;
            ctx.fillRect(0,0,48,64);

            const dither = (x,y,a,b)=>((x+y)&1)?a:b;

            for(let y=0;y<64;y++){
                for(let x=0;x<48;x++){
                    const c = map[y][x];
                    if(!c) continue;

                    if(c==="."){
                        ctx.fillStyle=dither(x,y,"rgba(0,0,0,.25)","rgba(0,0,0,0)");
                    }else if(c===":"){
                        ctx.fillStyle=dither(x,y,"rgba(255,255,255,.15)","rgba(255,255,255,0)");
                    }else{
                        ctx.fillStyle=C[c];
                    }
                    ctx.fillRect(x,y,1,1);
                }
            }
        }


// ===========================
// 1) Keep your 16x24 maps as BASE16
// 2) Auto-upscale to 32x48
// 3) Add detail patches
// ===========================

        function upscale2x(map16){
            // map16: array of 24 strings, width 16
            const out = [];
            for(const row of map16){
                let row2 = "";
                for(const ch of row){
                    row2 += ch + ch; // double width
                }
                out.push(row2);
                out.push(row2);    // double height
            }
            return out; // 48 strings, width 32
        }

        function applyPatches(map, patches){
            // patches: [{x,y,c}]
            const rows = map.map(r => r.split(""));
            for(const p of patches){
                if(p.y < 0 || p.y >= rows.length) continue;
                if(p.x < 0 || p.x >= rows[0].length) continue;
                rows[p.y][p.x] = p.c;
            }
            return rows.map(r => r.join(""));
        }

        /* ---------- BASE 16x24 (your earlier maps) ---------- */
        const SPRITES = {};

        SPRITES.indy = [
            "            OOOOOOOOOOOOOOOO            ",
            "         OOOOOOOOOOOOOOOOOOOOOO          ",
            "         OOOOOOOOOOOOOOOOOOOOOO          ",
            "          OOOOOOOOOOOOOOOOOOOO           ",
            "           OOOOOOOOOOOOOOOOOO            ",
            "            HHHHHHHHHHHHHHHH             ",
            "          HHSSSSSSSSSSSSSSSSHH           ",
            "         HSSSSSSSSSSSSSSSSSSSSH          ",
            "         HSSSSSSSSSSSSSSSSSSSSH          ",
            "          HSSSSSSSSSSSSSSSSSSH           ",
            "           HSSSSSSSSSSSSSSSSHH           ",
            "             TTTTTTTTTTTTTT              ",
            "            TTTTTTTTTTTTTTTT             ",
            "           TTTTTTTTTTTTTTTTTT            ",
            "          TTTTTTTTTTTTTTTTTTTT           ",
            "          TTTTTTTTTTTTTTTTTTTT           ",
            "           TTTTTTTTTTTTTTTTTT            ",
            "            TTTTTTTTTTTTTTTT             ",
            "             OOOOOOOOOOOOOO              ",
            "           OOOOOOOOOOOOOOOOOO            ",
            "          OOOOOOOOOOOOOOOOOOOO           ",
            "          OO::::::::::::::OOO           ",
            "           OO::::::::::::OOO            ",
            "            OO::::::::::OO              ",
            "              YY    YY                  ",
            "              YY    YY                  ",
            "            BBBBBBBBBBBBBBBB             ",
            "           BBBBBBBBBBBBBBBBBB            ",
            "          BBBB::::::::::::BBBB           ",
            "          BBB::::::::::::::BBB           ",
            "           BBB::::::::::::BBB            ",
            "            BBB::::::::::BBB             ",
            "             BB::::::::::BB              ",
            "              BB::::::::BB               ",
            "              BB::::::::BB               ",
            "              BB::::::::BB               ",
            "             BB::::::::::BB              ",
            "           HHH::::::::::::HHH            ",
            "          HHHH::::::::::::HHHH           ",
            "          HH::::::::::::::::HH           ",
            "           HH::::::::::::::HH            ",
            "            HH::::::::::::HH             ",
            "             HH::::::::::HH              ",
            "             HH::::::::::HH              ",
            "              HH::::::::HH               ",
            "               HH::::::HH                ",
            "                HHHHHHHH                 ",
            "                HHHHHHHH                 ",
            "                                           ",
            "                                           ",
            "                                           ",
            "                                           ",
            "                                           ",
            "                                           ",
            "                                           ",
            "                                           ",
            "                                           ",
            "                                           ",
            "                                           ",
            "                                           ",
            "                                           ",
            "                                           ",
            "                                           ",
            "                                           "
        ];

// Build final 32x48 maps on load
        const MAPS32 = {};
        for(const key of Object.keys(BASE16)){
            const up = upscale2x(BASE16[key]); // 32x48
            const patched = applyPatches(up, DETAIL_PATCHES[key] || []);
            MAPS32[key] = patched;
        }

        document.querySelectorAll("canvas.sprite").forEach(cv=>{
            const key = cv.dataset.sprite;
            if(SPRITES[key]) drawSprite(cv, SPRITES[key]);
        });


        // ===========================
        // Drag & drop + click fallback
        // ===========================
        const flashBad = document.getElementById("flashBad");
        const flashOk = document.getElementById("flashOk");
        const completeEl = document.getElementById("complete");

        function pulse(el){
            el.classList.remove("on");
            void el.offsetWidth;
            el.classList.add("on");
        }

        const names = [...document.querySelectorAll(".name")];
        const heroes = [...document.querySelectorAll(".hero")];

        let dragged = null;
        let selectedName = null;
        let solvedCount = 0;

        function markCompleteIfDone(){
            if(solvedCount >= 10){
                completeEl.classList.add("show");
                completeSfx();
            }
        }

        function tryAssign(nameEl, heroEl){
            if(!nameEl || !heroEl) return;
            if(heroEl.classList.contains("correct")) return;
            const answer = heroEl.dataset.answer;
            const value = nameEl.textContent.trim();

            if(value === answer){
                heroEl.classList.add("correct");
                heroEl.querySelector(".slot").textContent = value;
                nameEl.classList.add("used");
                nameEl.setAttribute("draggable", "false");
                nameEl.style.pointerEvents = "none";

                solvedCount++;
                pulse(flashOk);
                correct();
                markCompleteIfDone();
            }else{
                pulse(flashBad);
                wrong();
            }
        }

        // unlock audio on first gesture (dragstart / click)
        async function onUserGesture(){
            ensureAudioUnlocked();
            await resumeAudioIfNeeded();
        }

        // Drag handlers
        names.forEach(n => {
            n.addEventListener("dragstart", async () => {
                await onUserGesture();
                dragged = n;
                n.classList.add("dragging");
                clicky();
            });
            n.addEventListener("dragend", () => {
                n.classList.remove("dragging");
                dragged = null;
            });

            // Click-to-select fallback
            n.addEventListener("click", async () => {
                if(n.classList.contains("used")) return;
                await onUserGesture();
                clicky();
                selectedName = n;
                names.forEach(x => x.style.outline = "");
                n.style.outline = "2px solid rgba(0,255,102,.65)";
                n.style.outlineOffset = "2px";
            });
        });

        heroes.forEach(h => {
            h.addEventListener("dragover", e => e.preventDefault());
            h.addEventListener("drop", async () => {
                await onUserGesture();
                if(!dragged) return;
                tryAssign(dragged, h);
            });

            // Click fallback: click hero after selecting name
            h.addEventListener("click", async () => {
                if(!selectedName) return;
                await onUserGesture();
                tryAssign(selectedName, h);
                // clear selection after attempt
                names.forEach(x => x.style.outline = "");
                selectedName = null;
            });
        });

    })();
</script>
</body>
</html>
